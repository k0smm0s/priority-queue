
> priority-queue@1.0.0 test c:\rss\priority-queue
> mocha -r ./test/setup-mocha.js



  MaxHeap
    #constructor
      √ assigns null to this.root
      √ assigns [] to this.parentNodes
    #push
      √ calls insertNode with new node having passed data and priority
      √ calls shiftNodeUp with new node having passed data and priority
    #insertNode
      √ assings passed node to this.root if heap is empty
      1) inserts nodes to correct places
      2) maintains this.parentNodes in correct state
    #shiftNodeUp
      3) shifts node up until heap property is valid
      4) maintants parentNodes in correct state
      5) calls Node.swapWithParent
      6) calls itself recursively
    #clear
      √ assigns null to root and [] to parentNodes
    #pop
      √ does nothing if heap is empty
      7) returns data associated with root
      √ calls detachRoot
      √ calls restoreRootFromLastInsertedNode with detached root
      8) calls shiftNodeDown with current heap root
    #detachRoot
      √ assigns null to this.root
      9) removes root from parentNodes
      √ returns detached root
    #restoreRootFromLastInsertedNode
      10) should remove last inserted node and assing it to root
      11) should maintain correct state of parentNodes
      12) should maintain correct order of parentNodes when right child is moved
    #shiftNodeDown
      13) shifts node down until heap property is valid
      14) maintants parentNodes in correct state
      15) shifts node down in right direction
      16) calls Node.swapWithParent
      17) calls itself recursively
    #size
      √ returns current size of heap
    #isEmpty
      √ reutrns true if heap is empty

  Node
    #constructor
      √ assigns passed data and priority to this
      √ assigns this.parent, this.left and this.right to null
    #appendChild
      √ assigns passed child to this.left
      √ assigns passed child to this.right if this.left exists
      √ does nothing if this.left and this.right exist
    #removeChild
      √ assing null to this.left if passed node is left child
      √ assing null to this.right if passed node is right child
      √ throws error if passed node is not a child of this node
      18) assigns null to child.parent
    #remove
      √ does nothing if node does not have parent
      √ calls child.parent.removeChild with child as arg
    #swapWithParent
      √ does nothing if node does not have parent
parent parent
null
parent
Node {
  data: 15,
  priority: 42,
  parent: null,
  left:
   Node {
     data: 42,
     priority: 15,
     parent: [Circular],
     left: null,
     right: null },
  right: null }
child
Node {
  data: 15,
  priority: 42,
  parent: null,
  left:
   Node {
     data: 42,
     priority: 15,
     parent: [Circular],
     left: null,
     right: null },
  right: null }
========================
parent parent
      19) updates parent.parent
parent parent
Node {
  data: 8,
  priority: 8,
  parent: null,
  left:
   Node {
     data: 4,
     priority: 4,
     parent: [Circular],
     left:
      Node {
        data: 2,
        priority: 2,
        parent: [Circular],
        left: null,
        right: null },
     right: null },
  right: null }
parent
Node {
  data: 4,
  priority: 4,
  parent:
   Node {
     data: 8,
     priority: 8,
     parent: null,
     left: [Circular],
     right: null },
  left:
   Node {
     data: 2,
     priority: 2,
     parent: [Circular],
     left: null,
     right: null },
  right: null }
child
Node {
  data: 4,
  priority: 4,
  parent:
   Node {
     data: 8,
     priority: 8,
     parent: null,
     left: [Circular],
     right: null },
  left:
   Node {
     data: 2,
     priority: 2,
     parent: [Circular],
     left: null,
     right: null },
  right: null }
========================
parent parent
null
parent
Node {
  data: 8,
  priority: 8,
  parent: null,
  left:
   Node {
     data: 2,
     priority: 2,
     parent: [Circular],
     left:
      Node {
        data: 4,
        priority: 4,
        parent: [Circular],
        left: null,
        right: null,
        rigth: null },
     right: null },
  right: null }
child
Node {
  data: 8,
  priority: 8,
  parent: null,
  left:
   Node {
     data: 2,
     priority: 2,
     parent: [Circular],
     left:
      Node {
        data: 4,
        priority: 4,
        parent: [Circular],
        left: null,
        right: null,
        rigth: null },
     right: null },
  right: null }
      √ updates parent.parent.parent
parent parent
Node {
  data: 100,
  priority: 500,
  parent: null,
  left:
   Node {
     data: 15,
     priority: 42,
     parent: [Circular],
     left:
      Node {
        data: 42,
        priority: 15,
        parent: [Circular],
        left: null,
        right: null },
     right: null },
  right: null }
parent
Node {
  data: 15,
  priority: 42,
  parent:
   Node {
     data: 100,
     priority: 500,
     parent: null,
     left: [Circular],
     right: null },
  left:
   Node {
     data: 42,
     priority: 15,
     parent: [Circular],
     left: null,
     right: null },
  right: null }
child
Node {
  data: 15,
  priority: 42,
  parent:
   Node {
     data: 100,
     priority: 500,
     parent: null,
     left: [Circular],
     right: null },
  left:
   Node {
     data: 42,
     priority: 15,
     parent: [Circular],
     left: null,
     right: null },
  right: null }
========================
parent parent
null
parent
Node {
  data: 100,
  priority: 500,
  parent: null,
  left:
   Node {
     data: 42,
     priority: 15,
     parent: [Circular],
     left:
      Node {
        data: 15,
        priority: 42,
        parent: [Circular],
        left: null,
        right: null,
        rigth: null },
     right: null },
  right: null }
child
Node {
  data: 100,
  priority: 500,
  parent: null,
  left:
   Node {
     data: 42,
     priority: 15,
     parent: [Circular],
     left:
      Node {
        data: 15,
        priority: 42,
        parent: [Circular],
        left: null,
        right: null,
        rigth: null },
     right: null },
  right: null }
      √ updates child.parent
parent parent
null
parent
Node {
  data: 1,
  priority: 2,
  parent: null,
  left:
   Node {
     data: 3,
     priority: 4,
     parent: [Circular],
     left: null,
     right: null },
  right:
   Node {
     data: 5,
     priority: 6,
     parent: [Circular],
     left: null,
     right: null } }
child
Node {
  data: 1,
  priority: 2,
  parent: null,
  left:
   Node {
     data: 3,
     priority: 4,
     parent: [Circular],
     left: null,
     right: null },
  right:
   Node {
     data: 5,
     priority: 6,
     parent: [Circular],
     left: null,
     right: null } }
========================
parent parent
      20) updates parent.child.parent
parent parent
null
parent
Node {
  data: 42,
  priority: 15,
  parent: null,
  left:
   Node {
     data: 13,
     priority: 42,
     parent: [Circular],
     left:
      Node {
        data: 0,
        priority: 15,
        parent: [Circular],
        left: null,
        right: null },
     right: null },
  right:
   Node {
     data: 0,
     priority: 1,
     parent: [Circular],
     left: null,
     right: null } }
child
Node {
  data: 42,
  priority: 15,
  parent: null,
  left:
   Node {
     data: 13,
     priority: 42,
     parent: [Circular],
     left:
      Node {
        data: 0,
        priority: 15,
        parent: [Circular],
        left: null,
        right: null },
     right: null },
  right:
   Node {
     data: 0,
     priority: 1,
     parent: [Circular],
     left: null,
     right: null } }
========================
parent parent
      21) updates children of node and parent node
      22) maintains correct state of parent.parent.left and parent.parent.right

  PriorityQueue
    #constructor
      √ assings passed maxSize or set it to default value 30
      √ assings new MaxHeap to this.heap
    #push
      √ calls heap.push with passed data and priority
      23) throws an error if queue has max size
    #shift
      √ calls heap.pop
      24) returns value of removed node
      √ throws an error if queue is empty
      25) should return items sorted by priority
      26) should handle items with same priority (return in the same order this items have been added)
    #size
      27) returns current size of queue
    #isEmpty
      √ return true if queue is empty


  32 passing (130ms)
  27 failing

  1) MaxHeap #insertNode inserts nodes to correct places:
     AssertionError: expected null to equal { Object (data, priority, ...) }
      at Context.it (test\max-heap.spec.js:77:27)

  2) MaxHeap #insertNode maintains this.parentNodes in correct state:

      AssertionError: expected { Object (data, priority, ...) } to equal { Object (data, priority, ...) }
      + expected - actual

       {
      -  "data": 0
      +  "data": 1
         "left": [null]
         "parent": [null]
      -  "priority": 0
      +  "priority": 1
         "right": [null]
       }
      
      at Context.it (test\max-heap.spec.js:102:32)

  3) MaxHeap #shiftNodeUp shifts node up until heap property is valid:

      AssertionError: expected { Object (data, priority, ...) } to equal { Object (data, priority, ...) }
      + expected - actual

       {
      -  "data": 0
      -  "left": {
      +  "data": 3
      +  "left": [null]
      +  "parent": {
           "data": 1
      -    "left": {
      -      "data": 3
      -      "left": [null]
      -      "parent": [Circular]
      -      "priority": 20
      -      "right": [null]
      +    "left": [Circular]
      +    "parent": {
      +      "data": 0
      +      "left": [Circular]
      +      "parent": [null]
      +      "priority": 10
      +      "right": {
      +        "data": 2
      +        "left": [null]
      +        "parent": [Circular]
      +        "priority": 7
      +        "right": [null]
      +      }
           }
      -    "parent": [Circular]
           "priority": 5
           "right": [null]
         }
      -  "parent": [null]
      -  "priority": 10
      -  "right": {
      -    "data": 2
      -    "left": [null]
      -    "parent": [Circular]
      -    "priority": 7
      -    "right": [null]
      -  }
      +  "priority": 20
      +  "right": [null]
       }
      
      at Context.it (test\max-heap.spec.js:158:22)

  4) MaxHeap #shiftNodeUp maintants parentNodes in correct state:

      AssertionError: expected { Object (data, priority, ...) } to equal { Object (data, priority, ...) }
      + expected - actual

       {
      -  "data": 1
      +  "data": 0
         "left": {
      -    "data": 3
      -    "left": [null]
      -    "parent": [Circular]
      -    "priority": 20
      -    "right": [null]
      -  }
      -  "parent": {
      -    "data": 0
      -    "left": [Circular]
      -    "parent": [null]
      -    "priority": 10
      -    "right": {
      -      "data": 2
      +    "data": 1
      +    "left": {
      +      "data": 3
             "left": [null]
             "parent": [Circular]
      -      "priority": 7
      +      "priority": 20
             "right": [null]
           }
      +    "parent": [Circular]
      +    "priority": 5
      +    "right": [null]
         }
      -  "priority": 5
      -  "right": [null]
      +  "parent": [null]
      +  "priority": 10
      +  "right": {
      +    "data": 2
      +    "left": [null]
      +    "parent": [Circular]
      +    "priority": 7
      +    "right": [null]
      +  }
       }
      
      at Context.it (test\max-heap.spec.js:170:32)

  5) MaxHeap #shiftNodeUp calls Node.swapWithParent:
     AssertionError: expected swapWithParent to have been called exactly twice, but it was called 0 times
      at Context.it (test\max-heap.spec.js:181:53)

  6) MaxHeap #shiftNodeUp calls itself recursively:
     expected shiftNodeUp to have been called exactly thrice, but it was called once
    shiftNodeUp([Node] {
  data: 3,
  left: null,
  parent: [Node] {
    data: 1,
    left: [Circular],
    parent: [Node] {
      data: 0,
      left: [Circular],
      parent: null,
      priority: 10,
      right: [Node] { data: 2, left: null, parent: [Circular], priority: 7, right: null }
    },
    priority: 5,
    right: null
  },
  priority: 20,
  right: null
}) at Context.it (c:\rss\priority-queue\test\max-heap.spec.js:188:6)
  AssertionError: expected shiftNodeUp to have been called exactly thrice, but it was called once
      shiftNodeUp([Node] {
    data: 3,
    left: null,
    parent: [Node] {
      data: 1,
      left: [Circular],
      parent: [Node] {
        data: 0,
        left: [Circular],
        parent: null,
        priority: 10,
        right: [Node] { data: 2, left: null, parent: [Circular], priority: 7, right: null }
      },
      priority: 5,
      right: null
    },
    priority: 20,
    right: null
  }) at Context.it (test\max-heap.spec.js:188:6)
      at Context.it (test\max-heap.spec.js:190:38)

  7) MaxHeap #pop returns data associated with root:
     AssertionError: expected { Object (data, priority, ...) } to equal 100
      at Context.it (test\max-heap.spec.js:226:23)

  8) MaxHeap #pop calls shiftNodeDown with current heap root:
     AssertionError: expected shiftNodeDown to have been called with arguments null%D
      at Context.it (test\max-heap.spec.js:268:41)

  9) MaxHeap #detachRoot removes root from parentNodes:

      AssertionError: expected 15 to equal 42
      + expected - actual

      -15
      +42
      
      at Context.it (test\max-heap.spec.js:292:37)

  10) MaxHeap #restoreRootFromLastInsertedNode should remove last inserted node and assing it to root:
     TypeError: Cannot read property 'left' of null
      at Context.it (test\max-heap.spec.js:325:18)

  11) MaxHeap #restoreRootFromLastInsertedNode should maintain correct state of parentNodes:
     AssertionError: expected { Object (data, priority, ...) } to equal null
      at Context.it (test\max-heap.spec.js:338:32)

  12) MaxHeap #restoreRootFromLastInsertedNode should maintain correct order of parentNodes when right child is moved:

      AssertionError: expected [ 32, 0, 14, 13, 16, 12 ] to deeply equal [ 16, 14, 13, 0 ]
      + expected - actual

       [
      -  32
      -  0
      +  16
         14
         13
      -  16
      -  12
      +  0
       ]
      
      at Assertion.assertEqual (node_modules\chai\lib\chai\core\assertions.js:485:19)
      at Assertion.ctx.(anonymous function) [as equal] (node_modules\chai\lib\chai\utils\addMethod.js:41:25)
      at Context.it (test\max-heap.spec.js:359:53)

  13) MaxHeap #shiftNodeDown shifts node down until heap property is valid:

      AssertionError: expected { Object (data, priority, ...) } to equal { Object (data, priority, ...) }
      + expected - actual

       {
      -  "data": 0
      +  "data": 1
         "left": {
      -    "data": 1
      -    "left": {
      -      "data": 3
      +    "data": 3
      +    "left": [null]
      +    "parent": [Circular]
      +    "priority": 5
      +    "right": [null]
      +  }
      +  "parent": {
      +    "data": 0
      +    "left": [Circular]
      +    "parent": [null]
      +    "priority": 3
      +    "right": {
      +      "data": 2
             "left": [null]
             "parent": [Circular]
      -      "priority": 5
      +      "priority": 7
             "right": [null]
           }
      -    "parent": [Circular]
      -    "priority": 20
      -    "right": [null]
         }
      -  "parent": [null]
      -  "priority": 3
      -  "right": {
      -    "data": 2
      -    "left": [null]
      -    "parent": [Circular]
      -    "priority": 7
      -    "right": [null]
      -  }
      +  "priority": 20
      +  "right": [null]
       }
      
      at Context.it (test\max-heap.spec.js:395:22)

  14) MaxHeap #shiftNodeDown maintants parentNodes in correct state:

      AssertionError: expected { Object (data, priority, ...) } to equal { Object (data, priority, ...) }
      + expected - actual

       {
      -  "data": 1
      -  "left": {
      -    "data": 3
      -    "left": [null]
      -    "parent": [Circular]
      -    "priority": 5
      -    "right": [null]
      -  }
      +  "data": 3
      +  "left": [null]
         "parent": {
      -    "data": 0
      +    "data": 1
           "left": [Circular]
      -    "parent": [null]
      -    "priority": 3
      -    "right": {
      -      "data": 2
      -      "left": [null]
      -      "parent": [Circular]
      -      "priority": 7
      -      "right": [null]
      +    "parent": {
      +      "data": 0
      +      "left": [Circular]
      +      "parent": [null]
      +      "priority": 3
      +      "right": {
      +        "data": 2
      +        "left": [null]
      +        "parent": [Circular]
      +        "priority": 7
      +        "right": [null]
      +      }
           }
      +    "priority": 20
      +    "right": [null]
         }
      -  "priority": 20
      +  "priority": 5
         "right": [null]
       }
      
      at Context.it (test\max-heap.spec.js:408:32)

  15) MaxHeap #shiftNodeDown shifts node down in right direction:

      AssertionError: expected { Object (data, priority, ...) } to equal { Object (data, priority, ...) }
      + expected - actual

       {
      -  "data": 1
      +  "data": 20
         "left": {
      -    "data": 10
      +    "data": 11
      +    "left": [null]
      +    "parent": [Circular]
      +    "priority": 11
      +    "right": [null]
      +  }
      +  "parent": {
      +    "data": 1
           "left": {
      -      "data": 5
      -      "left": [null]
      +      "data": 10
      +      "left": {
      +        "data": 5
      +        "left": [null]
      +        "parent": [Circular]
      +        "priority": 5
      +        "right": [null]
      +      }
             "parent": [Circular]
      -      "priority": 5
      -      "right": [null]
      +      "priority": 10
      +      "right": {
      +        "data": 8
      +        "left": [null]
      +        "parent": [Circular]
      +        "priority": 8
      +        "right": [null]
      +      }
           }
      -    "parent": [Circular]
      -    "priority": 10
      -    "right": {
      -      "data": 8
      -      "left": [null]
      -      "parent": [Circular]
      -      "priority": 8
      -      "right": [null]
      -    }
      +    "parent": [null]
      +    "priority": 1
      +    "right": [Circular]
         }
      -  "parent": [null]
      -  "priority": 1
      +  "priority": 20
         "right": {
      -    "data": 20
      -    "left": {
      -      "data": 11
      -      "left": [null]
      -      "parent": [Circular]
      -      "priority": 11
      -      "right": [null]
      -    }
      +    "data": 6
      +    "left": [null]
           "parent": [Circular]
      -    "priority": 20
      -    "right": {
      -      "data": 6
      -      "left": [null]
      -      "parent": [Circular]
      -      "priority": 6
      -      "right": [null]
      -    }
      +    "priority": 6
      +    "right": [null]
         }
       }
      
      at Context.it (test\max-heap.spec.js:439:31)

  16) MaxHeap #shiftNodeDown calls Node.swapWithParent:
     AssertionError: expected swapWithParent to have been called exactly once, but it was called 0 times
      at Context.it (test\max-heap.spec.js:450:59)

  17) MaxHeap #shiftNodeDown calls itself recursively:
     expected shiftNodeDown to have been called exactly thrice, but it was called once
    shiftNodeDown([Node] {
  data: 0,
  left: [Node] {
    data: 1,
    left: [Node] { data: 3, left: null, parent: [Circular], priority: 5, right: null },
    parent: [Circular],
    priority: 20,
    right: null
  },
  parent: null,
  priority: 3,
  right: [Node] { data: 2, left: null, parent: [Circular], priority: 7, right: null }
}) at Context.it (c:\rss\priority-queue\test\max-heap.spec.js:457:6)
  AssertionError: expected shiftNodeDown to have been called exactly thrice, but it was called once
      shiftNodeDown([Node] {
    data: 0,
    left: [Node] {
      data: 1,
      left: [Node] { data: 3, left: null, parent: [Circular], priority: 5, right: null },
      parent: [Circular],
      priority: 20,
      right: null
    },
    parent: null,
    priority: 3,
    right: [Node] { data: 2, left: null, parent: [Circular], priority: 7, right: null }
  }) at Context.it (test\max-heap.spec.js:457:6)
      at Context.it (test\max-heap.spec.js:459:40)

  18) Node #removeChild assigns null to child.parent:
     AssertionError: expected { Object (data, priority, ...) } to equal null
      at Context.it (test\node.spec.js:87:32)

  19) Node #swapWithParent updates parent.parent:
     TypeError: Cannot read property 'parent' of null
      at Node.swapWithParent (src\node.js:122:27)
      at Context.it (test\node.spec.js:129:10)

  20) Node #swapWithParent updates parent.child.parent:
     TypeError: Cannot read property 'parent' of null
      at Node.swapWithParent (src\node.js:122:27)
      at Context.it (test\node.spec.js:168:10)

  21) Node #swapWithParent updates children of node and parent node:
     TypeError: Cannot read property 'parent' of null
      at Node.swapWithParent (src\node.js:122:27)
      at Context.it (test\node.spec.js:183:9)

  22) Node #swapWithParent maintains correct state of parent.parent.left and parent.parent.right:

      AssertionError: expected { Object (data, priority, ...) } to equal { Object (data, priority, ...) }
      + expected - actual

       {
      -  "data": 10
      -  "left": {
      -    "data": 100
      -    "left": [null]
      -    "parent": [Circular]
      -    "priority": 34
      -    "right": [null]
      -  }
      +  "data": 100
      +  "left": [null]
         "parent": {
      -    "data": 1
      +    "data": 10
           "left": [Circular]
      -    "parent": [null]
      -    "priority": 42
      -    "right": {
      -      "data": 50
      -      "left": {
      -        "data": 500
      -        "left": [null]
      +    "parent": {
      +      "data": 1
      +      "left": [Circular]
      +      "parent": [null]
      +      "priority": 42
      +      "right": {
      +        "data": 50
      +        "left": {
      +          "data": 500
      +          "left": [null]
      +          "parent": [Circular]
      +          "priority": 1
      +          "right": [null]
      +        }
               "parent": [Circular]
      -        "priority": 1
      +        "priority": 42
               "right": [null]
             }
      -      "parent": [Circular]
      -      "priority": 42
      -      "right": [null]
           }
      +    "priority": 15
      +    "right": [null]
         }
      -  "priority": 15
      +  "priority": 34
         "right": [null]
       }
      
      at Context.it (test\node.spec.js:205:25)

  23) PriorityQueue #push throws an error if queue has max size:
     ReferenceError: UserException is not defined
      at PriorityQueue.push (src\queue.js:16:4)
      at Context.it (test\queue.spec.js:37:6)

  24) PriorityQueue #shift returns value of removed node:
     AssertionError: expected { Object (data, priority, ...) } to equal 0
      at Context.it (test\queue.spec.js:63:25)

  25) PriorityQueue #shift should return items sorted by priority:
     AssertionError: expected { Object (data, priority, ...) } to equal 2
      at expectedData.forEach.d (test\queue.spec.js:87:51)
      at Array.forEach (<anonymous>)
      at Context.it (test\queue.spec.js:87:17)

  26) PriorityQueue #shift should handle items with same priority (return in the same order this items have been added):
     AssertionError: expected { Object (data, priority, ...) } to equal 3
      at Context.it (test\queue.spec.js:101:26)

  27) PriorityQueue #size returns current size of queue:

      AssertionError: expected 2 to equal 1
      + expected - actual

      -2
      +1
      
      at Context.it (test\queue.spec.js:111:24)



